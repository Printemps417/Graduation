import { StructSchema } from './utils';
import { StructError, Failure } from './error';
/**
 * `Struct` objects encapsulate the validation logic for a specific type of
 * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
 * validate unknown input data against the struct.
 */
export declare class Struct<T = unknown, S = unknown> {
    readonly TYPE: T;
    type: string;
    schema: S;
    coercer: Coercer;
    validator: Validator<T, S>;
    refiner: Refiner<T, S>;
    constructor(props: {
        type: Struct<T, S>['type'];
        schema: Struct<T, S>['schema'];
        coercer?: Struct<T, S>['coercer'];
        validator?: Struct<T, S>['validator'];
        refiner?: Struct<T, S>['refiner'];
    });
    /**
     * Assert that a value passes the struct's validation, throwing if it doesn't.
     */
    assert(value: unknown): asserts value is T;
    /**
     * Create a value with the struct's coercion logic, then validate it.
     */
    create(value: unknown): T;
    /**
     * Check if a value passes the struct's validation.
     */
    is(value: unknown): value is T;
    /**
     * Mask a value, coercing and validating it, but returning only the subset of
     * properties defined by the struct's schema.
     */
    mask(value: unknown): T;
    /**
     * Validate a value with the struct's validation logic, returning a tuple
     * representing the result.
     *
     * You may optionally pass `true` for the `withCoercion` argument to coerce
     * the value before attempting to validate it. If you do, the result will
     * contain the coerced result when successful.
     */
    validate(value: unknown, options?: {
        coerce?: boolean;
    }): [StructError, undefined] | [undefined, T];
}
/**
 * A `StructContext` contains information about the current value being
 * validated as well as helper functions for failures and recursive validating.
 */
export declare type Context<T, S> = {
    value: any;
    struct: Struct<T, S>;
    branch: Array<any>;
    path: Array<string | number>;
    fail: (props?: string | Partial<Failure>) => Failure;
    check: <Y, Z>(value: any, struct: Struct<Y, Z>, parent?: any, key?: string | number) => IterableIterator<Failure>;
};
/**
 * A type utility to extract the type from a `Struct` class.
 */
export declare type Infer<T extends Struct<any, any>> = T['TYPE'];
/**
 * A type utility to describe that a struct represents a TypeScript type.
 */
export declare type Describe<T> = Struct<T, StructSchema<T>>;
/**
 * A `Result` is returned from validation functions.
 */
export declare type Result = boolean | string | Iterable<Failure>;
/**
 * A `Coercer` takes an unknown value and optionally coerces it.
 */
export declare type Coercer = (value: unknown) => unknown;
/**
 * A `Validate` takes an unknown value and validates it.
 */
export declare type Validator<T, S> = (value: unknown, context: Context<T, S>) => Result;
/**
 * A `Refiner` takes a value of a known type and validates it against a further
 * constraint.
 */
export declare type Refiner<T, S> = (value: T, context: Context<T, S>) => Result;
/**
 * Assert that a value passes a `Struct`, throwing if it doesn't.
 */
export declare function assert<T, S>(value: unknown, struct: Struct<T, S>): asserts value is T;
/**
 * Create a value with the coercion logic of `Struct` and validate it.
 */
export declare function create<T, S>(value: unknown, struct: Struct<T, S>): T;
/**
 * Mask a value, returning only the subset of properties defined by a Struct.
 */
export declare function mask<T, S>(value: unknown, struct: Struct<T, S>): T;
/**
 * Check if a value passes a `Struct`.
 */
export declare function is<T, S>(value: unknown, struct: Struct<T, S>): value is T;
/**
 * Validate a value against a `Struct`, returning an error if invalid.
 */
export declare function validate<T, S>(value: unknown, struct: Struct<T, S>, options?: {
    coerce?: boolean;
}): [StructError, undefined] | [undefined, T];
//# sourceMappingURL=struct.d.ts.map